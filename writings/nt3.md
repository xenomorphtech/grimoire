f(AST) => AST
```
list.map(1..10, x: type ("Type" + int.to_string(x)) {})
```

root would be expression
 - type
 - mod
 - definition
 - function/lambda
 - operation(expression, expression)


fn x -> x: String, b: String, c: String -> String {

} 

fn(a: String) -> String {
  
}
x("something")


--
nttt

nice typed text transformer



```
fn emit_erlang(in: AST) -> CODE {

}


mod something where

fn a() {
}

let b = x: x + 1

mod something1 where


emit_erlang(something)

```

