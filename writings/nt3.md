f(AST) => AST
```
list.map(1..10, x: type ("Type" + int.to_string(x)) {})
```

root would be expression
 - type
 - mod
 - definition
 - function/lambda
 - operation(expression, expression)


fn x -> x: String, b: String, c: String -> String {

} 

fn(a: String) -> String {
  
}
x("something")


--
nttt

nice typed text transformer



```
fn emit_erlang(in: Ast) -> String {

}

mod something where

fn a() {
}

let b = x: x + 1

mod something1 where

the operator > only makes sense as comparator when applied to native types 

```

```

hotload consolidation of old -> new environment check 

```


some extra thought, like this expression:
```
when something is Error(..) raise("compilation error")
```
